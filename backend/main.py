#!/usr/bin/env python3\n\"\"\"\nLUA Assistant - Complete Backend Integration\nCombines all modules for production deployment\n\"\"\"\n\nfrom flask import Flask, request, jsonify, send_file\nfrom flask_cors import CORS\nimport os\nimport sys\nimport threading\nimport time\nfrom datetime import datetime\nimport json\nimport logging\n\n# Import our modules\nfrom speech_processor import AdvancedSpeechProcessor, SpeechCallback\nfrom device_integration import DeviceIntegration\nfrom ai_learning import LuaAILearning\nfrom database.lua_db import LuaDatabase\n\nfrom emotional_intelligence import EmotionalIntelligence

# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = Flask(__name__)\nCORS(app)\n\n# Initialize components\nspeech_processor = AdvancedSpeechProcessor()\ndevice_integration = DeviceIntegration()\nai_learning = LuaAILearning()\ndatabase = LuaDatabase()
emotional_ai = EmotionalIntelligence()\n\nclass LuaBackend:\n    def __init__(self):\n        self.is_listening = False\n        self.active_users = {}\n        self.command_queue = []\n        self.response_cache = {}\n        \n        # Initialize database\n        self.init_database()\n        \n        # Start background services\n        self.start_background_services()\n    \n    def init_database(self):\n        \"\"\"Initialize database with required tables\"\"\"\n        try:\n            # Add context column to commands table if not exists\n            import sqlite3\n            conn = sqlite3.connect('lua_assistant.db')\n            cursor = conn.cursor()\n            \n            try:\n                cursor.execute('ALTER TABLE commands ADD COLUMN context TEXT')\n                conn.commit()\n            except sqlite3.OperationalError:\n                pass  # Column already exists\n            \n            conn.close()\n            logger.info(\"Database initialized successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Database initialization error: {e}\")\n    \n    def start_background_services(self):\n        \"\"\"Start background services\"\"\"\n        # Start reminder checker\n        threading.Thread(target=self.reminder_checker, daemon=True).start()\n        \n        # Start model training scheduler\n        threading.Thread(target=self.model_training_scheduler, daemon=True).start()\n        \n        logger.info(\"Background services started\")\n    \n    def reminder_checker(self):\n        \"\"\"Check for due reminders\"\"\"\n        while True:\n            try:\n                import sqlite3\n                conn = sqlite3.connect('lua_assistant.db')\n                cursor = conn.cursor()\n                \n                # Check for due reminders\n                cursor.execute('''\n                    SELECT id, title, reminder_time FROM reminders\n                    WHERE reminder_time <= ? AND completed = FALSE\n                ''', (datetime.now(),))\n                \n                due_reminders = cursor.fetchall()\n                \n                for reminder_id, title, reminder_time in due_reminders:\n                    # Mark as completed\n                    cursor.execute(\n                        'UPDATE reminders SET completed = TRUE WHERE id = ?',\n                        (reminder_id,)\n                    )\n                    \n                    # Trigger notification (would integrate with system notifications)\n                    logger.info(f\"Reminder due: {title}\")\n                    \n                    # Could send push notification or speak reminder\n                    speech_processor.speak_text(f\"Reminder: {title}\", async_mode=True)\n                \n                conn.commit()\n                conn.close()\n                \n            except Exception as e:\n                logger.error(f\"Reminder checker error: {e}\")\n            \n            time.sleep(60)  # Check every minute\n    \n    def model_training_scheduler(self):\n        \"\"\"Schedule periodic model training\"\"\"\n        while True:\n            try:\n                time.sleep(3600)  # Every hour\n                \n                # Check if retraining is needed\n                if ai_learning._should_retrain():\n                    ai_learning._retrain_models()\n                    logger.info(\"AI models retrained\")\n                \n            except Exception as e:\n                logger.error(f\"Model training scheduler error: {e}\")\n    \n    def process_command(self, user_id, command_text, context=None):\n        \"\"\"Process command with full AI integration\"\"\"\n        try:\n            start_time = time.time()\n            \n            # Analyze emotion from text
            emotion_data = emotional_ai.analyze_emotion(command_text, user_id)
            
            # Get AI prediction for intent\n            prediction = ai_learning.predict_intent(user_id, command_text, context)\n            \n            # Process command based on predicted intent\n            if prediction['confidence'] > 0.6:\n                intent = prediction['intent']\n                result = self.execute_command(intent, command_text, context)\n            else:\n                # Fallback to rule-based processing\n                result = self.fallback_command_processing(command_text)\n            \n            # Add emotional response if needed
            if emotion_data['needs_empathy']:
                empathetic_response = emotional_ai.generate_empathetic_response(
                    emotion_data['emotion'], command_text
                )
                result['emotional_response'] = empathetic_response
                result['emotion_detected'] = emotion_data['emotion']
            
            # Learn from this interaction\n            success = result.get('action') != 'unknown'\n            ai_learning.learn_from_interaction(\n                user_id, command_text, result.get('action', 'unknown'), success, context\n            )\n            \n            # Log performance\n            processing_time = time.time() - start_time\n            logger.info(f\"Command processed in {processing_time:.2f}s: {command_text} -> {result.get('action')}\")\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Command processing error: {e}\")\n            return {\n                'action': 'error',\n                'response': 'Sorry, I encountered an error processing your command',\n                'error': str(e)\n            }\n    \n    def execute_command(self, intent, command_text, context):\n        \"\"\"Execute command based on intent\"\"\"\n        try:\n            if intent == 'open_app':\n                return self.handle_app_launch(command_text)\n            \n            elif intent == 'make_call':\n                return self.handle_phone_call(command_text)\n            \n            elif intent == 'send_message':\n                return self.handle_sms(command_text)\n            \n            elif intent == 'set_reminder':\n                return self.handle_reminder(command_text)\n            \n            elif intent == 'control_music':\n                return self.handle_music_control(command_text)\n            \n            elif intent == 'control_camera':\n                return self.handle_camera_control(command_text)\n            \n            elif intent == 'get_weather':\n                return self.handle_weather_request(command_text)\n            \n            else:\n                return self.fallback_command_processing(command_text)\n                \n        except Exception as e:\n            logger.error(f\"Command execution error: {e}\")\n            return {\n                'action': 'error',\n                'response': f'Error executing {intent}: {str(e)}'\n            }\n    \n    def handle_app_launch(self, command_text):\n        \"\"\"Handle app launching\"\"\"\n        # Extract app name\n        app_name = self.extract_app_name(command_text)\n        \n        # Get package name\n        package_name = speech_processor.app_packages.get(app_name.lower())\n        \n        if package_name:\n            # Launch app using device integration\n            result = device_integration.launch_app(app_name, package_name)\n            \n            if result['success']:\n                return {\n                    'action': 'open_app',\n                    'app_name': app_name,\n                    'package': package_name,\n                    'response': f'Opening {app_name.title()}',\n                    'success': True\n                }\n            else:\n                return {\n                    'action': 'error',\n                    'response': f'Failed to open {app_name}: {result.get(\"error\", \"Unknown error\")}',\n                    'success': False\n                }\n        else:\n            return {\n                'action': 'unknown',\n                'response': f'App \"{app_name}\" not found',\n                'success': False\n            }\n    \n    def handle_phone_call(self, command_text):\n        \"\"\"Handle phone calls\"\"\"\n        # Extract phone number or contact\n        import re\n        \n        # Look for phone number\n        phone_pattern = r'\\b\\d{10}\\b|\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b'\n        phone_match = re.search(phone_pattern, command_text)\n        \n        if phone_match:\n            phone_number = phone_match.group()\n            result = device_integration.make_call(phone_number=phone_number)\n            \n            return {\n                'action': 'make_call',\n                'phone_number': phone_number,\n                'response': f'Calling {phone_number}',\n                'success': result['success']\n            }\n        \n        # Extract contact name\n        contact_words = ['call', 'phone', 'dial']\n        words = command_text.split()\n        contact_name = None\n        \n        for i, word in enumerate(words):\n            if word.lower() in contact_words and i + 1 < len(words):\n                contact_name = ' '.join(words[i+1:]).strip()\n                break\n        \n        if contact_name:\n            result = device_integration.make_call(contact_name=contact_name)\n            \n            return {\n                'action': 'make_call',\n                'contact_name': contact_name,\n                'response': f'Calling {contact_name}',\n                'success': result['success']\n            }\n        \n        return {\n            'action': 'unknown',\n            'response': 'Please specify a contact name or phone number',\n            'success': False\n        }\n    \n    def handle_sms(self, command_text):\n        \"\"\"Handle SMS sending\"\"\"\n        import re\n        \n        # Pattern: \"send message to [contact] saying [message]\"\n        message_pattern = r'(?:send|text).*?(?:to|message)\\s+([^\\s]+).*?(?:saying|that|message)\\s+(.+)'\n        match = re.search(message_pattern, command_text, re.IGNORECASE)\n        \n        if match:\n            contact = match.group(1)\n            message = match.group(2)\n            \n            result = device_integration.send_sms(contact_name=contact, message=message)\n            \n            return {\n                'action': 'send_sms',\n                'contact': contact,\n                'message': message,\n                'response': f'Sending message to {contact}: {message}',\n                'success': result['success']\n            }\n        \n        return {\n            'action': 'unknown',\n            'response': 'Please specify contact and message. Say \"send message to John saying hello\"',\n            'success': False\n        }\n    \n    def handle_reminder(self, command_text):\n        \"\"\"Handle reminder setting\"\"\"\n        # Extract time and title\n        import re\n        \n        time_patterns = [\n            r'(?:at|in)\\s+(\\d{1,2}(?::\\d{2})?\\s*(?:am|pm|AM|PM))',\n            r'(?:in)\\s+(\\d+)\\s*(?:minutes?|mins?|hours?|hrs?)',\n            r'(?:tomorrow|today|tonight)'\n        ]\n        \n        extracted_time = 'now'\n        for pattern in time_patterns:\n            match = re.search(pattern, command_text, re.IGNORECASE)\n            if match:\n                extracted_time = match.group(0)\n                break\n        \n        # Extract title\n        title = command_text\n        for keyword in ['remind', 'reminder', 'alert']:\n            title = title.replace(keyword, '').strip()\n        \n        if extracted_time != 'now':\n            title = title.replace(extracted_time, '').strip()\n        \n        title = re.sub(r'\\b(?:me|to|about|that)\\b', '', title, flags=re.IGNORECASE).strip()\n        title = title or 'Reminder'\n        \n        result = device_integration.set_reminder(title, extracted_time)\n        \n        return {\n            'action': 'set_reminder',\n            'title': title,\n            'time': extracted_time,\n            'response': result['message'] if result['success'] else result['error'],\n            'success': result['success']\n        }\n    \n    def handle_music_control(self, command_text):\n        \"\"\"Handle music control\"\"\"\n        if 'play' in command_text.lower():\n            action = 'play_music'\n        elif any(word in command_text.lower() for word in ['pause', 'stop']):\n            action = 'pause_music'\n        elif any(word in command_text.lower() for word in ['next', 'skip']):\n            action = 'next_track'\n        elif any(word in command_text.lower() for word in ['previous', 'back']):\n            action = 'previous_track'\n        elif 'volume up' in command_text.lower():\n            action = 'volume_up'\n        elif 'volume down' in command_text.lower():\n            action = 'volume_down'\n        else:\n            action = 'play_music'\n        \n        result = device_integration.control_music(action)\n        \n        return {\n            'action': action,\n            'response': result['message'] if result['success'] else result['error'],\n            'success': result['success']\n        }\n    \n    def handle_camera_control(self, command_text):\n        \"\"\"Handle camera control\"\"\"\n        mode = 'default'\n        if any(word in command_text.lower() for word in ['selfie', 'front']):\n            mode = 'front'\n        \n        result = device_integration.control_camera(mode)\n        \n        return {\n            'action': 'open_camera',\n            'mode': mode,\n            'response': result['message'] if result['success'] else result['error'],\n            'success': result['success']\n        }\n    \n    def handle_weather_request(self, command_text):\n        \"\"\"Handle weather requests\"\"\"\n        # Mock weather data (integrate with real API in production)\n        return {\n            'action': 'get_weather',\n            'location': 'current location',\n            'weather_data': {\n                'temperature': '25°C',\n                'condition': 'Sunny',\n                'humidity': '60%'\n            },\n            'response': 'Current weather: 25°C, Sunny with 60% humidity',\n            'success': True\n        }\n    \n    def extract_app_name(self, command_text):\n        \"\"\"Extract app name from command\"\"\"\n        words = command_text.lower().split()\n        stop_words = ['open', 'launch', 'start', 'run', 'the', 'app', 'application']\n        app_words = [word for word in words if word not in stop_words]\n        \n        return ' '.join(app_words) if app_words else command_text\n    \n    def fallback_command_processing(self, command_text):\n        \"\"\"Fallback command processing using rule-based approach\"\"\"\n        # Use the original LuaAssistant logic as fallback\n        from app import LuaAssistant\n        fallback_assistant = LuaAssistant()\n        return fallback_assistant.process_command(command_text)\n\n# Initialize backend\nlua_backend = LuaBackend()\n\n# API Routes\n@app.route('/', methods=['GET'])\ndef home():\n    \"\"\"API home endpoint\"\"\"\n    return jsonify({\n        'service': 'LUA Assistant Backend',\n        'version': '1.0.0',\n        'status': 'running',\n        'features': [\n            'Advanced Speech Recognition',\n            'AI Learning & Prediction',\n            'Device Integration',\n            'Smart Command Processing',\n            'User Behavior Analysis'\n        ],\n        'endpoints': {\n            'process_voice': '/api/process_voice',\n            'speech_to_text': '/api/speech_to_text',\n            'text_to_speech': '/api/text_to_speech',\n            'user_stats': '/api/user_stats',\n            'user_insights': '/api/user_insights',\n            'suggestions': '/api/suggestions',\n            'device_info': '/api/device_info',\n            'health': '/health'\n        }\n    })\n\n@app.route('/api/process_voice', methods=['POST'])\ndef process_voice():\n    \"\"\"Process voice command with full AI integration\"\"\"\n    try:\n        data = request.get_json()\n        user_id = data.get('user_id', 'default')\n        command_text = data.get('text', '')\n        context = data.get('context', {})\n        \n        if not command_text:\n            return jsonify({'error': 'No command text provided'}), 400\n        \n        # Process command\n        result = lua_backend.process_command(user_id, command_text, context)\n        \n        return jsonify(result)\n        \n    except Exception as e:\n        logger.error(f\"Voice processing error: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/speech_to_text', methods=['POST'])\ndef speech_to_text():\n    \"\"\"Convert speech to text\"\"\"\n    try:\n        if 'audio' not in request.files:\n            return jsonify({'error': 'No audio file provided'}), 400\n        \n        audio_file = request.files['audio']\n        \n        # Save temporary file\n        temp_path = f'/tmp/{audio_file.filename}'\n        audio_file.save(temp_path)\n        \n        # Process with speech recognition\n        result = speech_processor.recognize_from_file(temp_path)\n        \n        # Clean up\n        os.remove(temp_path)\n        \n        return jsonify(result)\n        \n    except Exception as e:\n        logger.error(f\"Speech to text error: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/text_to_speech', methods=['POST'])\ndef text_to_speech():\n    \"\"\"Convert text to speech\"\"\"\n    try:\n        data = request.get_json()\n        text = data.get('text', '')\n        async_mode = data.get('async', True)\n        \n        if not text:\n            return jsonify({'error': 'No text provided'}), 400\n        \n        success = speech_processor.speak_text(text, async_mode)\n        \n        return jsonify({\n            'status': 'success' if success else 'error',\n            'text': text\n        })\n        \n    except Exception as e:\n        logger.error(f\"Text to speech error: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/user_stats', methods=['GET'])\ndef get_user_stats():\n    \"\"\"Get user statistics\"\"\"\n    try:\n        user_id = request.args.get('user_id', 'default')\n        stats = database.get_user_stats(user_id)\n        return jsonify(stats)\n        \n    except Exception as e:\n        logger.error(f\"User stats error: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/user_insights', methods=['GET'])\ndef get_user_insights():\n    \"\"\"Get AI-powered user insights\"\"\"\n    try:\n        user_id = request.args.get('user_id', 'default')\n        insights = ai_learning.get_user_insights(user_id)\n        return jsonify(insights)\n        \n    except Exception as e:\n        logger.error(f\"User insights error: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/suggestions', methods=['GET'])\ndef get_suggestions():\n    \"\"\"Get personalized suggestions\"\"\"\n    try:\n        user_id = request.args.get('user_id', 'default')\n        suggestions = ai_learning.get_personalized_suggestions(user_id)\n        return jsonify({'suggestions': suggestions})\n        \n    except Exception as e:\n        logger.error(f\"Suggestions error: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/api/emotion_analysis', methods=['POST'])
def analyze_emotion():
    """Analyze emotion from text"""
    try:
        data = request.get_json()
        text = data.get('text', '')
        user_id = data.get('user_id', 'default')
        
        if not text:
            return jsonify({'error': 'No text provided'}), 400
        
        result = emotional_ai.analyze_emotion(text, user_id)
        return jsonify(result)
        
    except Exception as e:
        logger.error(f"Emotion analysis error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/device_info', methods=['GET'])\ndef get_device_info():\n    \"\"\"Get device information\"\"\"\n    try:\n        info = device_integration.get_device_info()\n        return jsonify(info)\n        \n    except Exception as e:\n        logger.error(f\"Device info error: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({\n        'status': 'healthy',\n        'timestamp': datetime.now().isoformat(),\n        'components': {\n            'speech_processor': 'running',\n            'device_integration': 'running',\n            'ai_learning': 'running',\n            'emotional_ai': 'running',
            'database': 'connected'\n        }\n    })\n\nif __name__ == '__main__':\n    port = int(os.environ.get('PORT', 5000))\n    debug = os.environ.get('FLASK_ENV') == 'development'\n    \n    logger.info(f\"Starting LUA Assistant Backend on port {port}\")\n    logger.info(f\"Debug mode: {debug}\")\n    \n    app.run(host='0.0.0.0', port=port, debug=debug)